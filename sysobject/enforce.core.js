// Generated by CoffeeScript 1.6.1
var ANALOGSTICK, ASPECT, BUFFER, CAMERA, CIRCLE, COLLADA, CONTROL, CUBE, CYLINDER, DEG, EFFECT, HORIZONTAL, ICOSAHEDRON, JSLog, LAPSEDTIME, LIGHT, MOTION_ACCEL, PADAXES, PADBUTTONS, PIXELRATIO, PLANE, PRIMITIVE, RAD, RENDERER, SCREEN_HEIGHT, SCREEN_WIDTH, SENSOR, SPHERE, TORUS, TORUSKNOT, VERTICAL, VRSTATE, WORLD_FACTOR, addObject, enterframe, gamepadProcedure, getBounds, getCookie, getKeyDirection, getObject, isWebGL, nop, rand, removeObject, rootScene, setCookie, setMotionObj, sprintf, uniqueID, _GAMEPADPROCEDURE_, _GAMEPADSINFO, _browserMajorClass, _defaultbrowser, _getNullObject, _keyinput, _main, _objects, _originObject, _standardbrowser, _stationary, _useragent,
  __slice = [].slice;

_originObject = (function() {

  function _originObject() {
    this.active = false;
  }

  return _originObject;

})();

_stationary = (function() {

  function _stationary(initparam) {
    var _this = this;
    this._processnumber = 0;
    this._waittime = 0.0;
    this._dispframe = 0;
    this._endflag = false;
    this._returnflag = false;
    this._autoRemove = false;
    this._animTime = LAPSEDTIME * 1000;
    this.sprite = initparam['motionsprite'];
    if ((this.sprite != null)) {
      this.x = initparam['x'];
      this.y = initparam['y'];
      this.z = initparam['z'];
      this.oldx = initparam['x'];
      this.oldy = initparam['y'];
      this.oldz = initparam['z'];
      this.xs = initparam['xs'];
      this.ys = initparam['ys'];
      this.zs = initparam['zs'];
      this.oldys = initparam['ys'];
      this.visible = initparam['visible'];
      this.scaleX = initparam['scaleX'];
      this.scaleY = initparam['scaleY'];
      this.scaleZ = initparam['scaleZ'];
      this.alpha = initparam['alpha'];
      this.beta = initparam['beta'];
      this.gamma = initparam['gamma'];
      this.vcanvas = initparam['vcanvas'];
      this.vtexture = initparam['vtexture'];
      this.gravity = initparam['gravity'];
      this.intersectFlag = initparam['intersectFlag'];
      this.opacity = initparam['opacity'];
      this.sprite.ontouchstart = function(e) {
        var pos;
        pos = {
          x: e.x,
          y: e.y
        };
        if (typeof _this.touchesBegan === 'function') {
          return _this.touchesBegan(pos);
        }
      };
      this.sprite.ontouchmove = function(e) {
        var pos;
        pos = {
          x: e.x,
          y: e.y
        };
        if (typeof _this.touchesMoved === 'function') {
          return _this.touchesMoved(pos);
        }
      };
      this.sprite.ontouchend = function(e) {
        var pos;
        pos = {
          x: e.x,
          y: e.y
        };
        if (typeof _this.touchesEnded === 'function') {
          return _this.touchesEnded(pos);
        }
      };
      this.sprite.ontouchcancel = function(e) {
        var pos;
        pos = {
          x: e.x,
          y: e.y
        };
        if (typeof _this.touchesCanceled === 'function') {
          return _this.touchesCanceled(pos);
        }
      };
      this.intersectFlag = true;
    }
  }

  _stationary.prototype.destructor = function() {};

  _stationary.prototype.behavior = function() {
    if ((this.sprite != null)) {
      this.sprite.position.set(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
      this.sprite.visible = this.visible;
      this.sprite.scale.set(this.scaleX, this.scaleY, this.scaleZ);
      if (this.alpha > 360) {
        this.alpha = this.alpha % 360;
      }
      if (this.beta > 360) {
        this.beta = this.beta % 360;
      }
      if (this.gamma > 360) {
        this.gamma = this.gamma % 360;
      }
      this.sprite.rotation.x = this.alpha / 180 * Math.PI;
      this.sprite.rotation.y = this.beta / 180 * Math.PI;
      this.sprite.rotation.z = this.gamma / 180 * Math.PI;
      this.ys -= this.gravity;
      this.x += this.xs;
      this.y += this.ys;
      this.z += this.zs;
      this.sprite.x = Math.floor(this.x);
      this.sprite.y = Math.floor(this.y);
      this.sprite.z = Math.floor(this.z);
    }
    if (this._waittime > 0 && LAPSEDTIME > this._waittime) {
      this._waittime = 0;
      return this._processnumber = this._nextprocessnum;
    }
  };

  _stationary.prototype.touchesBegan = function(e) {};

  _stationary.prototype.touchesMoved = function(e) {};

  _stationary.prototype.touchesEnded = function(e) {};

  _stationary.prototype.touchesCanceled = function(e) {};

  _stationary.prototype.nextjob = function() {
    return this._processnumber++;
  };

  _stationary.prototype.waitjob = function(wtime) {
    this._waittime = LAPSEDTIME + wtime;
    this._nextprocessnum = this._processnumber + 1;
    return this._processnumber = -1;
  };

  _stationary.prototype.setProcessNumber = function(num) {
    return this._processnumber = num;
  };

  _stationary.prototype.isWithIn = function(motionObj, range) {
    var ret;
    if (range == null) {
      range = -1;
    }
    ret = true;
    if (motionObj == null) {
      ret = false;
    }
    return ret;
  };

  _stationary.prototype.isIntersect = function(motionObj) {
    var ret;
    ret = true;
    if (motionObj.sprite == null) {
      ret = false;
    }
    return ret;
  };

  _stationary.prototype.setModel = function(name) {
    var model;
    model = MEDIALIST[name];
    return this.set(core.assets[model]);
  };

  return _stationary;

})();

rand = function(n) {
  return Math.floor(Math.random() * (n + 1));
};

JSLog = function() {
  var a, b, data, _i, _len;
  a = arguments[0], b = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (DEBUG === true) {
    for (_i = 0, _len = b.length; _i < _len; _i++) {
      data = b[_i];
      a = a.replace('%@', data);
    }
    return console.log(a);
  }
};

sprintf = function() {
  var a, b, data, _i, _len;
  a = arguments[0], b = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = b.length; _i < _len; _i++) {
    data = b[_i];
    a = a.replace('%@', data);
  }
  return a;
};

uniqueID = function() {
  var S4;
  S4 = function() {
    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
  };
  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
};

getBounds = function() {
  var frame;
  frame = [parseInt(document.documentElement.clientWidth - 1), parseInt(document.documentElement.clientHeight - 1)];
  return frame;
};

getKeyDirection = function() {
  var dir;
  dir = {
    x: 0,
    y: 0
  };
  if (core.input.up) {
    dir['y'] = -1;
  }
  if (core.input.down) {
    dir['y'] = 1;
  }
  if (core.input.right) {
    dir['x'] = 1;
  }
  if (core.input.left) {
    dir['x'] = -1;
  }
  return dir;
};

setCookie = function(name, value, expireValue) {
  if (expireValue == null) {
    expireValue = 1;
  }
  return $.cookie(name, value, {
    expires: expireValue
  });
};

getCookie = function(name) {
  return $.cookie(name);
};

isWebGL = function() {
  try {
    return !!window.WebGLRenderingContext && !!document.createElement('canvas').getContext('experimental-webgl');
  } catch (e) {
    return false;
  }
};

nop = function() {};

CONTROL = 0;

COLLADA = 10;

PRIMITIVE = 20;

PLANE = 0;

CUBE = 1;

CIRCLE = 2;

CYLINDER = 3;

SPHERE = 4;

ICOSAHEDRON = 5;

TORUS = 6;

TORUSKNOT = 7;

BUFFER = 8;

HORIZONTAL = 0;

VERTICAL = 1;

_keyinput = [];

_GAMEPADSINFO = [];

PADBUTTONS = [];

PADBUTTONS[0] = [false, false];

PADAXES = [];

PADAXES[0] = [0, 0];

ANALOGSTICK = [];

ANALOGSTICK[0] = [0, 0, 0, 0];

MOTION_ACCEL = [
  {
    x: 0,
    y: 0,
    z: 0
  }
];

SENSOR = void 0;

RAD = Math.PI / 180.0;

DEG = 180.0 / Math.PI;

_useragent = window.navigator.userAgent.toLowerCase();

if (_useragent.match(/^.*android.*mobile safari.*$/i) && !_useragent.match(/^.*[^0.9] chrome.*/i)) {
  _standardbrowser = true;
} else {
  _standardbrowser = false;
}

LAPSEDTIME = 0;

RENDERER = void 0;

CAMERA = void 0;

LIGHT = void 0;

EFFECT = void 0;

_objects = [];

_main = void 0;

rootScene = void 0;

WORLD_FACTOR = 1.0;

VRSTATE = void 0;

_useragent = window.navigator.userAgent.toLowerCase();

if (_useragent.match(/^.*android.*?mobile safari.*$/i) !== null && _useragent.match(/^.*\) chrome.*/i) === null) {
  _defaultbrowser = true;
} else {
  _defaultbrowser = false;
}

if (_useragent.match(/.* firefox\/.*/)) {
  _browserMajorClass = "firefox";
} else if (_useragent.match(/.*version\/.* safari\/.*/)) {
  _browserMajorClass = "safari";
} else if (_useragent.match(/.*chrome\/.* safari\/.*/)) {
  _browserMajorClass = "chrome";
} else {
  _browserMajorClass = "unknown";
}

PIXELRATIO = window.devicePixelRatio;

SCREEN_WIDTH = window.innerWidth;

SCREEN_HEIGHT = window.innerHeight + (_browserMajorClass === "chrome" ? 48 : 0);

ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;

window.onload = function() {
  var LIGHT2, OculusRift, STATUSAREA, i, modelarr, obj, renderelm, webglelm, _i;
  STATUSAREA = document.getElementById('status');
  if ((typeof MEDIALIST !== "undefined" && MEDIALIST !== null)) {
    modelarr = [];
    i = 0;
    for (obj in MEDIALIST) {
      modelarr[i++] = MEDIALIST[obj];
    }
  }
  RENDERER = new THREE.WebGLRenderer();
  RENDERER.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
  renderelm = RENDERER.domElement;
  webglelm = document.getElementById('webgl');
  webglelm.appendChild(renderelm);
  CAMERA = new THREE.PerspectiveCamera(270, ASPECT, 0.1, 3000);
  CAMERA.position.set(0, 0, 0);
  rootScene = new THREE.Scene();
  rootScene.fog = new THREE.FogExp2(FOGCOLOR, FOGLEVEL);
  if (VRMODE === true) {
    vr.load(function(error) {});
    VRSTATE = new vr.State();
    OculusRift = {
      hResolution: SCREEN_WIDTH,
      vResolution: SCREEN_HEIGHT,
      hScreenSize: 0.14976,
      vScreenSize: 0.0936,
      interpupillaryDistance: 0.064,
      lensSeparationDistance: 0.064,
      eyeToScreenDistance: 0.041,
      distortionK: [1.0, 0.22, 0.24, 0.0],
      chromaAbParameter: [0.996, -0.004, 1.014, 0.0]
    };
    EFFECT = new THREE.OculusRiftEffect(RENDERER, {
      HMD: OculusRift,
      worldFactor: WORLD_FACTOR
    });
  } else {
    CAMERA.lookAt(new THREE.Vector3(0, 0, 0));
  }
  rootScene.add(CAMERA);
  LIGHT = new THREE.DirectionalLight(0xffffff, 0.5);
  LIGHT.position = new THREE.Vector3(300.0, 300.0, 300.0);
  LIGHT.castShadow = true;
  rootScene.add(LIGHT);
  LIGHT2 = new THREE.AmbientLight(0xffffff);
  rootScene.add(LIGHT2);
  SENSOR = new THREE.DeviceOrientationControls(CAMERA);
  for (i = _i = 0; 0 <= OBJECTNUM ? _i < OBJECTNUM : _i > OBJECTNUM; i = 0 <= OBJECTNUM ? ++_i : --_i) {
    _objects[i] = new _originObject();
  }
  _main = new enforceMain();
  enterframe();
  document.addEventListener('keydown', function(e) {
    var keycode;
    if (e == null) {
      e = window.event;
    }
    keycode = e.keyCode;
    _keyinput[keycode] = true;
    if (_keyinput[32]) {
      e.preventDefault();
      vr.resetHmdOrientation();
    }
    if (_keyinput[70]) {
      e.preventDefault();
      if (vr.isFullScreen() === true) {
        return vr.exitFullScreen();
      } else {
        return vr.enterFullScreen(true);
      }
    }
  });
  document.addEventListener('keyup', function(e) {
    var keycode;
    if (e == null) {
      e = window.event;
    }
    keycode = e.keyCode;
    return _keyinput[keycode] = false;
  });
  window.addEventListener('resize', function() {
    STATUSAREA.innerHTML = "width=" + SCREEN_WIDTH + ", height=" + SCREEN_HEIGHT + ", raitio=" + PIXELRATIO;
    SCREEN_WIDTH = window.innerWidth;
    SCREEN_HEIGHT = window.innerHeight + (_browserMajorClass === "chrome" ? 48 : 0);
    OculusRift = {
      hResolution: SCREEN_WIDTH,
      vResolution: SCREEN_HEIGHT,
      hScreenSize: 0.14976,
      vScreenSize: 0.0936,
      interpupillaryDistance: 0.064,
      lensSeparationDistance: 0.064,
      eyeToScreenDistance: 0.041,
      distortionK: [1.0, 0.22, 0.24, 0.0],
      chromaAbParameter: [0.996, -0.004, 1.014, 0.0]
    };
    ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;
    CAMERA.aspect = ASPECT;
    CAMERA.updateProjectionMatrix();
    RENDERER.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    return EFFECT = new THREE.OculusRiftEffect(RENDERER, {
      HMD: OculusRift,
      worldFactor: WORLD_FACTOR
    });
  }, false);
  return STATUSAREA.innerHTML = "width=" + SCREEN_WIDTH + ", height=" + SCREEN_HEIGHT + ", raitio=" + PIXELRATIO;
};

enterframe = function() {
  var num, obj, padobj, _i, _j, _len, _ref;
  for (_i = 0, _len = _objects.length; _i < _len; _i++) {
    obj = _objects[_i];
    if (obj.active === true && obj.motionObj !== void 0 && typeof obj.motionObj.behavior === 'function') {
      obj.motionObj.behavior();
      if ((obj.motionObj.vcanvas != null)) {
        if (obj.motionObj.vcanvas.readyState === obj.motionObj.vcanvas.HAVE_ENOUGH_DATA) {
          if (obj.motionObj.vtexture) {
            obj.motionObj.vtexture.needsUpdate = true;
          }
        }
      }
      if (typeof gamepadProcedure === 'function') {
        _GAMEPADSINFO = gamepadProcedure();
        for (num = _j = 0, _ref = _GAMEPADSINFO.length; 0 <= _ref ? _j < _ref : _j > _ref; num = 0 <= _ref ? ++_j : --_j) {
          if (_GAMEPADSINFO[num] == null) {
            continue;
          }
          padobj = _GAMEPADSINFO[num];
          PADBUTTONS[num] = _GAMEPADSINFO[num].padbuttons;
          PADAXES[num] = _GAMEPADSINFO[num].padaxes;
          ANALOGSTICK[num] = _GAMEPADSINFO[num].analogstick;
        }
      }
      if (_keyinput[90] || _keyinput[32]) {
        PADBUTTONS[0][0] = true;
      } else if (_GAMEPADSINFO[0] == null) {
        PADBUTTONS[0][0] = false;
      }
      if (_keyinput[88]) {
        PADBUTTONS[0][1] = true;
      } else if (_GAMEPADSINFO[0] == null) {
        PADBUTTONS[0][1] = false;
      }
      if (_keyinput[37]) {
        PADAXES[0][HORIZONTAL] = -1;
      } else if (_keyinput[38]) {
        PADAXES[0][HORIZONTAL] = 1;
      } else if (_GAMEPADSINFO[0] == null) {
        PADAXES[0][HORIZONTAL] = 0;
      }
      if (_keyinput[39]) {
        PADAXES[0][VERTICAL] = -1;
      } else if (_keyinput[40]) {
        PADAXES[0][VERTICAL] = 1;
      } else if (_GAMEPADSINFO[0] == null) {
        PADAXES[0][VERTICAL] = 0;
      }
    }
  }
  if (VRMODE === true) {
    if (!vr.pollState(VRSTATE)) {
      return;
    }
    if (VRSTATE.hmd.present) {
      CAMERA.quaternion.x = VRSTATE.hmd.rotation[0];
      CAMERA.quaternion.y = VRSTATE.hmd.rotation[1];
      CAMERA.quaternion.z = VRSTATE.hmd.rotation[2];
      CAMERA.quaternion.w = VRSTATE.hmd.rotation[3];
    } else {
      SENSOR.update();
    }
    EFFECT.render(rootScene, CAMERA);
  } else {
    RENDERER.render(rootScene, CAMERA);
  }
  return setTimeout(enterframe, 1000 / FPS);
};

addObject = function(param) {
  var alpha, beta, color, depth, divx, divy, gamma, geometry, gravity, height, loader, map, material, model, motionObj, motionsprite, opacity, radius, retObject, retobject, scaleX, scaleY, scaleZ, texture, vcanvas, video, videoautoplay, videoloop, visible, vtexture, width, x, xs, y, ys, z, zs, _type;
  motionObj = (param.motionObj != null) ? param.motionObj : void 0;
  _type = (param.type != null) ? param.type : GLSPHERE;
  x = (param.x != null) ? param.x : 0.0;
  y = (param.y != null) ? param.y : 0.0;
  z = (param.z != null) ? param.z : 0.0;
  xs = (param.xs != null) ? param.xs : 0.0;
  ys = (param.ys != null) ? param.ys : 0.0;
  zs = (param.zs != null) ? param.zs : 0.0;
  radius = (param.radius != null) ? param.radius : 10.0;
  width = (param.width != null) ? param.width : 10.0;
  height = (param.height != null) ? param.height : 10.0;
  depth = (param.depth != null) ? param.depth : 10.0;
  color = (param.color != null) ? param.color : 'gray';
  gravity = (param.gravity != null) ? param.gravity : 0.0;
  model = (param.model != null) ? param.model : void 0;
  opacity = (param.opacity != null) ? param.opacity : 1.0;
  visible = (param.visible != null) ? param.visible : true;
  scaleX = (param.scaleX != null) ? param.scaleX : 1.0;
  scaleY = (param.scaleY != null) ? param.scaleY : 1.0;
  scaleZ = (param.scaleZ != null) ? param.scaleZ : 1.0;
  alpha = (param.alpha != null) ? param.alpha : 0.0;
  beta = (param.beta != null) ? param.beta : 0.0;
  gamma = (param.gamma != null) ? param.gamma : 0.0;
  divx = (param.divx != null) ? param.divx : 64;
  divy = (param.divy != null) ? param.divy : 64;
  texture = (param.texture != null) ? param.texture : void 0;
  video = (param.video != null) ? param.video : void 0;
  videoautoplay = (param.videoautoplay != null) ? param.videoautoplay : false;
  videoloop = (param.videoloop != null) ? param.videoloop : false;
  if (motionObj === void 0) {
    motionObj = void 0;
  }
  switch (_type) {
    case COLLADA:
      if ((MEDIALIST[model] != null)) {
        loader = new THREE.ColladaLoader();
        loader.options.convertUpAxis = true;
        return loader.load(MEDIALIST[model]);
        /*
            JSLog(collada)
            motionsprite = collada.scene
            motionsprite.position.set(x, y, z)
            motionsprite.scale.set(scaleX, scaleY, scaleZ)
            rootScene.add(motionsprite)
            # 動きを定義したオブジェクトを生成する
            retObject = @setMotionObj(x, y, z, xs, ys, zs, visible, scaleX, scaleY, scaleZ, gravity, opacity, _type, motionsprite, motionObj, alpha, beta, gamma, vcanvas, vtexture)
            return retObject
        */

      } else {
        retobject = void 0;
        motionsprite = void 0;
        return retObject;
      }
      break;
    case PRIMITIVE:
      switch (model) {
        case PLANE:
          geometry = new THREE.PlaneGeometry(width, height, divx, divy);
          break;
        case CUBE:
          geometry = new THREE.BoxGeometry(width, height, depth);
          break;
        case CIRCLE:
          nop();
          break;
        case CYLINDER:
          nop();
          break;
        case SPHERE:
          geometry = new THREE.SphereGeometry(radius, width, height);
          break;
        case ICOSAHEDRON:
          nop();
          break;
        case TORUS:
          nop();
          break;
        case TORUSKNOT:
          nop();
          break;
        case BUFFER:
          nop();
      }
      if ((texture != null)) {
        map = THREE.ImageUtils.loadTexture(MEDIALIST[texture]);
        material = new THREE.MeshLambertMaterial({
          map: map,
          color: color
        });
      } else if ((video != null)) {
        vcanvas = document.createElement('video');
        vcanvas.src = MEDIALIST[video];
        vcanvas.load();
        vcanvas.autoplay = videoautoplay;
        vcanvas.loop = videoloop;
        vtexture = new THREE.Texture(vcanvas);
        vtexture.minFilter = THREE.LinearFilter;
        vtexture.magFilter = THREE.LinearFilter;
        material = new THREE.MeshLambertMaterial({
          map: vtexture,
          overdraw: true,
          side: THREE.DoubleSide
        });
      } else {
        material = new THREE.MeshPhongMaterial({
          color: color,
          ambient: 0x303030,
          specular: 0xffffff,
          shininess: 1,
          metal: true
        });
      }
      motionsprite = new THREE.Mesh(geometry, material);
      motionsprite.position.set(x, y, z);
      rootScene.add(motionsprite);
      retObject = this.setMotionObj(x, y, z, xs, ys, zs, visible, scaleX, scaleY, scaleZ, gravity, opacity, _type, motionsprite, motionObj, alpha, beta, gamma, vcanvas, vtexture);
      return retObject;
  }
};

setMotionObj = function(x, y, z, xs, ys, zs, visible, scaleX, scaleY, scaleZ, gravity, opacity, _type, motionsprite, motionObj, alpha, beta, gamma, vcanvas, vtexture) {
  var initparam, obj, objnum, uid;
  initparam = [];
  initparam['x'] = x;
  initparam['y'] = y;
  initparam['z'] = z;
  initparam['oldx'] = x;
  initparam['oldy'] = y;
  initparam['oldz'] = z;
  initparam['xs'] = xs;
  initparam['ys'] = ys;
  initparam['zs'] = zs;
  initparam['oldys'] = ys;
  initparam['visible'] = visible;
  initparam['scaleX'] = scaleX;
  initparam['scaleY'] = scaleY;
  initparam['scaleZ'] = scaleZ;
  initparam['alpha'] = alpha;
  initparam['beta'] = beta;
  initparam['gamma'] = gamma;
  initparam['gravity'] = gravity;
  initparam['intersectFlag'] = true;
  initparam['opacity'] = opacity;
  initparam['motionsprite'] = motionsprite;
  initparam['vcanvas'] = vcanvas;
  initparam['vtexture'] = vtexture;
  objnum = _getNullObject();
  if (objnum < 0) {
    return void 0;
  }
  obj = _objects[objnum];
  obj.active = true;
  if ((motionObj != null)) {
    obj.motionObj = new motionObj(initparam);
  } else {
    obj.motionObj = new _stationary(initparam);
  }
  uid = uniqueID();
  obj.motionObj._uniqueID = uid;
  obj.motionObj._type = _type;
  return obj.motionObj;
};

removeObject = function(motionObj) {
  var object, ret, _i, _len;
  if (motionObj == null) {
    return;
  }
  ret = false;
  for (_i = 0, _len = _objects.length; _i < _len; _i++) {
    object = _objects[_i];
    if (object.motionObj == null) {
      continue;
    }
    if (object.motionObj._uniqueID === motionObj._uniqueID) {
      ret = true;
      break;
    }
  }
  if (ret === false) {
    return;
  }
  if (typeof motionObj.destructor === 'function') {
    motionObj.destructor();
  }
  rootScene.remove(object.motionObj.sprite);
  object.motionObj.sprite = void 0;
  object.motionObj = void 0;
  return object.active = false;
};

getObject = function(id) {
  var i, ret, _i, _ref;
  ret = void 0;
  for (i = _i = 0, _ref = _objects.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (_objects[i] == null) {
      continue;
    }
    if (_objects[i].motionObj == null) {
      continue;
    }
    if (_objects[i].motionObj._uniqueID === id) {
      ret = _objects[i].motionObj;
      break;
    }
  }
  return ret;
};

_getNullObject = function() {
  var i, ret, _i, _ref;
  ret = -1;
  for (i = _i = 0, _ref = _objects.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (_objects[i].active === false) {
      ret = i;
      break;
    }
  }
  return ret;
};

_GAMEPADPROCEDURE_ = [];

_GAMEPADPROCEDURE_['firefox_gamepad'] = function(gamepadsinfo) {
  var analogstick, axes, bt, btnum, buttons, gamepad, id, index, max, padaxes, padbuttons, padnum, padresult, _i, _j, _ref;
  padresult = [];
  for (padnum = _i = 0, _ref = gamepadsinfo.length; 0 <= _ref ? _i < _ref : _i > _ref; padnum = 0 <= _ref ? ++_i : --_i) {
    gamepad = gamepadsinfo[padnum];
    if (gamepad == null) {
      continue;
    }
    buttons = gamepad.buttons;
    axes = gamepad.axes;
    index = gamepad.index;
    id = gamepad.id;
    max = (buttons.length < 6 ? buttons.length : 6);
    padbuttons = [];
    for (btnum = _j = 0; 0 <= max ? _j < max : _j > max; btnum = 0 <= max ? ++_j : --_j) {
      bt = buttons[btnum];
      padbuttons[btnum] = bt.pressed;
    }
    if (id.match(/.*45e.*?28e.*/)) {
      padbuttons[6] = buttons[9].pressed;
      padbuttons[7] = buttons[8].pressed;
    } else {
      padbuttons[6] = buttons[6].pressed;
      padbuttons[7] = buttons[7].pressed;
    }
    analogstick = [];
    analogstick[0] = [gamepad.axes[0], gamepad.axes[1]];
    analogstick[1] = [gamepad.axes[2], gamepad.axes[3]];
    padaxes = [];
    if (((gamepad.buttons[13] != null) && gamepad.buttons[13].pressed) || gamepad.axes[0].pressed || parseInt(gamepad.axes[0]) < 0) {
      padaxes[0] = -1;
    } else if (((gamepad.buttons[14] != null) && gamepad.buttons[14].pressed) || gamepad.axes[0].pressed || parseInt(gamepad.axes[0]) > 0) {
      padaxes[0] = 1;
    } else {
      padaxes[0] = 0;
    }
    if (((gamepad.buttons[11] != null) && gamepad.buttons[11].pressed) || gamepad.axes[1].pressed || parseInt(gamepad.axes[1]) < 0) {
      padaxes[1] = -1;
    } else if (((gamepad.buttons[12] != null) && gamepad.buttons[12].pressed) || gamepad.axes[1].pressed || parseInt(gamepad.axes[1]) > 0) {
      padaxes[1] = 1;
    } else {
      padaxes[1] = 0;
    }
    padresult[index] = [];
    padresult[index].id = id;
    padresult[index].padbuttons = padbuttons;
    padresult[index].padaxes = padaxes;
    padresult[index].analogstick = analogstick;
  }
  return padresult;
};

_GAMEPADPROCEDURE_['chrome_gamepad'] = function(gamepadsinfo) {
  var analogstick, axes, bt, btnum, buttons, gamepad, id, index, max, padaxes, padbuttons, padnum, padresult, _i, _j, _ref;
  padresult = [];
  for (padnum = _i = 0, _ref = gamepadsinfo.length; 0 <= _ref ? _i < _ref : _i > _ref; padnum = 0 <= _ref ? ++_i : --_i) {
    gamepad = gamepadsinfo[padnum];
    if (gamepad == null) {
      continue;
    }
    buttons = gamepad.buttons;
    axes = gamepad.axes;
    index = gamepad.index;
    id = gamepad.id;
    max = (buttons.length < 6 ? buttons.length : 6);
    padbuttons = [];
    for (btnum = _j = 0; 0 <= max ? _j < max : _j > max; btnum = 0 <= max ? ++_j : --_j) {
      bt = buttons[btnum];
      padbuttons[btnum] = bt.pressed;
    }
    if (id.match(/.*45e.*?28e.*/)) {
      padbuttons[6] = buttons[8].pressed;
      padbuttons[7] = buttons[9].pressed;
    } else {
      padbuttons[6] = buttons[6].pressed;
      padbuttons[7] = buttons[7].pressed;
    }
    analogstick = [];
    analogstick[0] = [gamepad.axes[0], gamepad.axes[1]];
    analogstick[1] = [gamepad.axes[2], gamepad.axes[3]];
    padaxes = [];
    if (((gamepad.buttons[14] != null) && gamepad.buttons[14].pressed) || gamepad.axes[0].pressed || parseInt(gamepad.axes[0]) < 0) {
      padaxes[0] = -1;
    } else if (((gamepad.buttons[15] != null) && gamepad.buttons[15].pressed) || gamepad.axes[0].pressed || parseInt(gamepad.axes[0]) > 0) {
      padaxes[0] = 1;
    } else {
      padaxes[0] = 0;
    }
    if (((gamepad.buttons[12] != null) && gamepad.buttons[12].pressed) || gamepad.axes[1].pressed || parseInt(gamepad.axes[1]) < 0) {
      padaxes[1] = -1;
    } else if (((gamepad.buttons[13] != null) && gamepad.buttons[13].pressed) || gamepad.axes[1].pressed || parseInt(gamepad.axes[1]) > 0) {
      padaxes[1] = 1;
    } else {
      padaxes[1] = 0;
    }
    padresult[index] = [];
    padresult[index].id = id;
    padresult[index].padbuttons = padbuttons;
    padresult[index].padaxes = padaxes;
    padresult[index].analogstick = analogstick;
  }
  return padresult;
};

gamepadProcedure = function() {
  var browserGamepadFunctionName, gamepadsinfo, padresult, _ua;
  _ua = window.navigator.userAgent.toLowerCase();
  if (_ua.match(/.* firefox\/.*/)) {
    _browserMajorClass = "firefox";
  } else if (_ua.match(/.*version\/.* safari\/.*/)) {
    _browserMajorClass = "safari";
  } else if (_ua.match(/.*chrome\/.* safari\/.*/)) {
    _browserMajorClass = "chrome";
  } else {
    _browserMajorClass = "unknown";
  }
  padresult = [];
  browserGamepadFunctionName = _browserMajorClass + "_gamepad";
  if (typeof _GAMEPADPROCEDURE_[browserGamepadFunctionName] === 'function') {
    gamepadsinfo = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
    if ((gamepadsinfo != null) && gamepadsinfo.length > 0) {
      padresult = _GAMEPADPROCEDURE_[browserGamepadFunctionName](gamepadsinfo);
    }
  }
  return padresult;
};
